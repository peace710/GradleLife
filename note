在app、librarys和根目录的build.gradle文件分别加入
println "build.gradle in root"
println "build.gradle in app"
println "build.gradle in librarys"

执行gradlew -q task
结果如下
build.gradle in root
build.gradle in app
build.gradle in librarys

在根目录里的settings.gradle
通过include方法引入需要构建的子项目

项目配置
//通过path定位并获取该 Project 对象
project(path: String): Project
//通过path定位一个Project，并进行配置
project(path: String, config: Closure): Project

//针对所有项目进行配置
allprojects(config: Closure)
//针对所有子项目进行配置
subprojects(config: Closure)

apply
//使用插件，com.android.application 就是插件id
apply plugin: 'com.android.application'
//使用插件，MyPluginImpl 就是一个Plugin接口的实现类
apply plugin: MyPluginImpl
//引用其他gradle脚本，push.gradle就是另外一个gradle脚本文件
apply from: './push.gradle'

在与 build.gradle 文件同级目录下，定义一个名为 gradle.properties 文件，里面定义的键值对，可以在 Project 中直接访问


ExtensionContainer
一般我们通过 ExtensionContainer 来创建 Extension，这个类与 TaskContainer 命名有点类似，
TaskContainer 是用来创建并管理 Task 的,而 ExtensionContainer 则是用来创建并管理 Extension 的


创建Extension
<T> T create​(String name, Class<T> type, Object... constructionArguments)
<T> T create​(Class<T> publicType, String name, Class<? extends T> instanceType, Object... constructionArguments)

增加Extension
void add​(Class<T> publicType, String name, T extension)
void add​(String name, T extension)

查找Extension
Object findByName(String name)
<T> T findByType(Class<T> type)
Object getByName(String name)       //找不到会抛异常
<T> T getByType(Class<T> type)  //找不到会抛异常

创建NamedDomainObjectContainer
<T> NamedDomainObjectContainer<T> container​(Class<T> type)
<T> NamedDomainObjectContainer<T> container​(Class<T> type, NamedDomainObjectFactory<T> factory)
<T> NamedDomainObjectContainer<T> container​(java.lang.Class<T> type, Closure factoryClosure)

查找和遍历
//遍历
void all(Closure action)
//查找
<T> T getByName(String name)
//查找
<T> T findByName(String name)


